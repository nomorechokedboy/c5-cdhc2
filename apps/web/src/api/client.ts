// Code generated by the Encore v1.49.1 client generator. DO NOT EDIT.

// Disable eslint, jshint, and jslint for this file.
/* eslint-disable */
/* jshint ignore:start */
/*jslint-disable*/

/**
 * BaseURL is the base URL for calling the Encore application's API.
 */
export type BaseURL = string

export const Local: BaseURL = 'http://localhost:4000'

/**
 * Environment returns a BaseURL for calling the cloud environment with the given name.
 */
export function Environment(name: string): BaseURL {
	return `https://${name}-ibibi.encr.app`
}

/**
 * PreviewEnv returns a BaseURL for calling the preview environment with the given PR number.
 */
export function PreviewEnv(pr: number | string): BaseURL {
	return Environment(`pr${pr}`)
}

const BROWSER = typeof globalThis === 'object' && 'window' in globalThis

/**
 * Client is an API client for the ibibi Encore application.
 */
export default class Client {
	public readonly auth: auth.ServiceClient
	public readonly classes: classes.ServiceClient
	public readonly healthcheck: healthcheck.ServiceClient
	public readonly notifications: notifications.ServiceClient
	public readonly permissions: permissions.ServiceClient
	public readonly students: students.ServiceClient
	public readonly units: units.ServiceClient
	public readonly users: users.ServiceClient
	private readonly options: ClientOptions
	private readonly target: string

	/**
	 * Creates a Client for calling the public and authenticated APIs of your Encore application.
	 *
	 * @param target  The target which the client should be configured to use. See Local and Environment for options.
	 * @param options Options for the client
	 */
	constructor(target: BaseURL, options?: ClientOptions) {
		this.target = target
		this.options = options ?? {}
		const base = new BaseClient(this.target, this.options)
		this.auth = new auth.ServiceClient(base)
		this.classes = new classes.ServiceClient(base)
		this.healthcheck = new healthcheck.ServiceClient(base)
		this.notifications = new notifications.ServiceClient(base)
		this.permissions = new permissions.ServiceClient(base)
		this.students = new students.ServiceClient(base)
		this.units = new units.ServiceClient(base)
		this.users = new users.ServiceClient(base)
	}

	/**
	 * Creates a new Encore client with the given client options set.
	 *
	 * @param options Client options to set. They are merged with existing options.
	 **/
	public with(options: ClientOptions): Client {
		return new Client(this.target, {
			...this.options,
			...options
		})
	}
}

/**
 * ClientOptions allows you to override any default behaviour within the generated Encore client.
 */
export interface ClientOptions {
	/**
	 * By default the client will use the inbuilt fetch function for making the API requests.
	 * however you can override it with your own implementation here if you want to run custom
	 * code on each API request made or response received.
	 */
	fetcher?: Fetcher

	/** Default RequestInit to be used for the client */
	requestInit?: Omit<RequestInit, 'headers'> & {
		headers?: Record<string, string>
	}

	/**
	 * Allows you to set the authentication data to be used for each
	 * request either by passing in a static object or by passing in
	 * a function which returns a new object for each request.
	 */
	auth?: auth.AuthParams | AuthDataGenerator
}

export namespace auth {
	export interface AuthParams {
		authorization: string
	}

	export interface ChangeUserPasswordRequest {
		prevPassword: string
		password: string
	}

	export interface GetUserInfoResponse {
		data: users.User
	}

	export interface LoginRequest {
		username: string
		password: string
	}

	export interface LoginResponse {
		accessToken: string
		refreshToken: string
	}

	export interface RefreshTokenRequest {
		token: string
	}

	export interface RefreshTokenResponse {
		accessToken: string
		refreshToken: string
	}

	export class ServiceClient {
		private baseClient: BaseClient

		constructor(baseClient: BaseClient) {
			this.baseClient = baseClient
			this.ChangeUserPassword = this.ChangeUserPassword.bind(this)
			this.GetUserInfo = this.GetUserInfo.bind(this)
			this.Login = this.Login.bind(this)
			this.RefreshToken = this.RefreshToken.bind(this)
		}

		public async ChangeUserPassword(
			params: ChangeUserPasswordRequest
		): Promise<void> {
			await this.baseClient.callTypedAPI(
				'PATCH',
				`/authn/change-pwd`,
				JSON.stringify(params)
			)
		}

		public async GetUserInfo(): Promise<GetUserInfoResponse> {
			// Now make the actual call to the API
			const resp = await this.baseClient.callTypedAPI('GET', `/authn/me`)
			return (await resp.json()) as GetUserInfoResponse
		}

		public async Login(params: LoginRequest): Promise<LoginResponse> {
			// Now make the actual call to the API
			const resp = await this.baseClient.callTypedAPI(
				'POST',
				`/authn/login`,
				JSON.stringify(params)
			)
			return (await resp.json()) as LoginResponse
		}

		public async RefreshToken(
			params: RefreshTokenRequest
		): Promise<RefreshTokenResponse> {
			// Now make the actual call to the API
			const resp = await this.baseClient.callTypedAPI(
				'POST',
				`/authn/refresh`,
				JSON.stringify(params)
			)
			return (await resp.json()) as RefreshTokenResponse
		}
	}
}

export namespace classes {
	export interface BulkClassResponse {
		data: ClassResponse[]
	}

	export interface Class {
		id: number
		createdAt: string
		updatedAt: string
		name: string
		description: string
		graduatedAt: string | null
		status: 'ongoing' | 'graduated'
		unit: units.UnitDB
	}

	export interface ClassBody {
		name: string
		description?: string
		graduatedAt?: string
		unitId: number
	}

	export interface ClassResponse {
		id: number
		createdAt: string
		updatedAt: string
		name: string
		description: string
		graduatedAt: string | null
		status: 'ongoing' | 'graduated'
		unitId: number
	}

	export interface DeleteClassRequest {
		ids: number[]
	}

	export interface DeleteClassResponse {
		ids: number[]
	}

	export interface GetClassByIdResponse {
		data?: Class
	}

	export interface GetClassesRequest {
		ids?: number[]
		unitIds?: number[]
	}

	export interface GetClassesResponse {
		data: ClassResponse[]
	}

	export interface UpdateClassBody {
		data: UpdatePayload[]
	}

	export interface UpdatePayload {
		id: number
		name?: string
		description?: string
		graduatedAt?: string
		unitId?: number
	}

	export class ServiceClient {
		private baseClient: BaseClient

		constructor(baseClient: BaseClient) {
			this.baseClient = baseClient
			this.CreateClass = this.CreateClass.bind(this)
			this.DeleteClasss = this.DeleteClasss.bind(this)
			this.GetClassById = this.GetClassById.bind(this)
			this.GetClasses = this.GetClasses.bind(this)
			this.UpdateClasss = this.UpdateClasss.bind(this)
		}

		public async CreateClass(
			params: ClassBody
		): Promise<BulkClassResponse> {
			// Now make the actual call to the API
			const resp = await this.baseClient.callTypedAPI(
				'POST',
				`/classes`,
				JSON.stringify(params)
			)
			return (await resp.json()) as BulkClassResponse
		}

		public async DeleteClasss(
			params: DeleteClassRequest
		): Promise<DeleteClassResponse> {
			// Convert our params into the objects we need for the request
			const query = makeRecord<string, string | string[]>({
				ids: params.ids.map((v) => String(v))
			})

			// Now make the actual call to the API
			const resp = await this.baseClient.callTypedAPI(
				'DELETE',
				`/classes`,
				undefined,
				{ query }
			)
			return (await resp.json()) as DeleteClassResponse
		}

		public async GetClassById(id: number): Promise<GetClassByIdResponse> {
			// Now make the actual call to the API
			const resp = await this.baseClient.callTypedAPI(
				'GET',
				`/classes/${encodeURIComponent(id)}`
			)
			return (await resp.json()) as GetClassByIdResponse
		}

		public async GetClasses(
			params: GetClassesRequest
		): Promise<GetClassesResponse> {
			// Convert our params into the objects we need for the request
			const query = makeRecord<string, string | string[]>({
				ids: params.ids?.map((v) =>
					v === undefined ? undefined : String(v)
				),
				unitIds: params.unitIds?.map((v) =>
					v === undefined ? undefined : String(v)
				)
			})

			// Now make the actual call to the API
			const resp = await this.baseClient.callTypedAPI(
				'GET',
				`/classes`,
				undefined,
				{ query }
			)
			return (await resp.json()) as GetClassesResponse
		}

		public async UpdateClasss(params: UpdateClassBody): Promise<void> {
			await this.baseClient.callTypedAPI(
				'PATCH',
				`/classes`,
				JSON.stringify(params)
			)
		}
	}
}

export namespace healthcheck {
	export interface HeathCheckResponse {
		uptime: string
		timestamp: number
	}

	export class ServiceClient {
		private baseClient: BaseClient

		constructor(baseClient: BaseClient) {
			this.baseClient = baseClient
			this.Heathz = this.Heathz.bind(this)
		}

		public async Heathz(): Promise<HeathCheckResponse> {
			// Now make the actual call to the API
			const resp = await this.baseClient.callTypedAPI('POST', `/healthz`)
			return (await resp.json()) as HeathCheckResponse
		}
	}
}

export namespace notifications {
	export interface GetNotificationsQuery {
		page?: number
		pageSize?: number
	}

	export interface GetNotificationsResponse {
		data: NotificationResponse[]
	}

	export interface GetUnreadCountResponse {
		data: {
			count: number
		}
	}

	export interface Handshake {
		userId: number
	}

	export interface MarkAsReadRequest {
		ids: string[]
	}

	export interface Message {
		type:
			| 'ping'
			| 'birthdayThisWeek'
			| 'birthdayThisMonth'
			| 'birthdayThisQuarter'
			| 'cpvOfficialThisWeek'
			| 'cpvOfficialThisMonth'
			| 'cpvOfficialThisQuarter'
		data: {
			title: string
			message: string
			userId: number
		}
	}

	export interface NotificationItemResponse {
		id: number
		createdAt: string
		updatedAt: string
		notifiableType: 'classes' | 'students'
		notifiableId: number
		notificationId: string
	}

	export interface NotificationResponse {
		id: string
		createdAt: string
		readAt: string
		notificationType: 'birthday' | 'officialCpv'
		title: string
		message: string
		isBatch: boolean
		batchKey: string
		totalCount: number
		items: NotificationItemResponse[]
	}

	export class ServiceClient {
		private baseClient: BaseClient

		constructor(baseClient: BaseClient) {
			this.baseClient = baseClient
			this.GetNotifications = this.GetNotifications.bind(this)
			this.GetUnreadCount = this.GetUnreadCount.bind(this)
			this.MarkAsRead = this.MarkAsRead.bind(this)
			this.NotificationStream = this.NotificationStream.bind(this)
		}

		public async GetNotifications(
			params: GetNotificationsQuery
		): Promise<GetNotificationsResponse> {
			// Convert our params into the objects we need for the request
			const query = makeRecord<string, string | string[]>({
				page:
					params.page === undefined ? undefined : String(params.page),
				pageSize:
					params.pageSize === undefined
						? undefined
						: String(params.pageSize)
			})

			// Now make the actual call to the API
			const resp = await this.baseClient.callTypedAPI(
				'GET',
				`/notifications`,
				undefined,
				{ query }
			)
			return (await resp.json()) as GetNotificationsResponse
		}

		public async GetUnreadCount(): Promise<GetUnreadCountResponse> {
			// Now make the actual call to the API
			const resp = await this.baseClient.callTypedAPI(
				'GET',
				`/notifications/unread`
			)
			return (await resp.json()) as GetUnreadCountResponse
		}

		public async MarkAsRead(params: MarkAsReadRequest): Promise<void> {
			await this.baseClient.callTypedAPI(
				'PATCH',
				`/notifications/mark-as-read`,
				JSON.stringify(params)
			)
		}

		public async NotificationStream(
			params: Handshake
		): Promise<StreamIn<Message>> {
			// Convert our params into the objects we need for the request
			const query = makeRecord<string, string | string[]>({
				userId: String(params.userId)
			})

			return await this.baseClient.createStreamIn(
				`/notifications/stream`,
				{ query }
			)
		}
	}
}

export namespace permissions {
	export interface CreatePermissionRequest {
		actionId: number
		resourceId: number
	}

	export class ServiceClient {
		private baseClient: BaseClient

		constructor(baseClient: BaseClient) {
			this.baseClient = baseClient
			this.CreatePermission = this.CreatePermission.bind(this)
		}

		public async CreatePermission(
			params: CreatePermissionRequest
		): Promise<void> {
			await this.baseClient.callTypedAPI(
				'POST',
				`/permissions`,
				JSON.stringify(params)
			)
		}
	}
}

export namespace students {
	export interface BulkStudentResponse {
		data: StudentDBResponse[]
	}

	export interface ChildrenInfo {
		fullName: string
		dob: string
	}

	export interface DeleteStudentRequest {
		ids: number[]
	}

	export interface DeleteStudentResponse {
		ids: number[]
	}

	export interface GetPoliticsQualityReportRequest {
		unitIds: number[]
	}

	export interface GetPoliticsQualityReportResponse {
		data: { [key: number]: { [key: string]: any } }
		units: units.Unit[]
	}

	export interface GetStudentsQuery {
		birthdayInMonth?: Month
		birthdayInQuarter?: Quarter
		birthdayInWeek?: boolean
		classId?: number
		hasReligion?: boolean
		ids?: number[]
		isEthnicMinority?: boolean
		isMarried?: boolean
		politicalOrg?: 'hcyu' | 'cpv'
		unitAlias?: string
		unitLevel?: 'battalion' | 'company'
		isCpvOfficialThisWeek?: boolean
		cpvOfficialInMonth?: Month
		cpvOfficialInQuarter?: Quarter
		classIds?: number[]
	}

	export interface GetStudentsResponse {
		data: StudentResponse[]
	}

	export type Month =
		| '01'
		| '02'
		| '03'
		| '04'
		| '05'
		| '06'
		| '07'
		| '08'
		| '09'
		| '10'
		| '11'
		| '12'

	export type Quarter = 'Q1' | 'Q2' | 'Q3' | 'Q4'

	export interface StudentBody {
		fullName: string
		birthPlace: string
		address: string
		dob: string
		rank: string
		previousUnit: string
		previousPosition: string
		ethnic: string
		religion: string
		enlistmentPeriod: string
		politicalOrg: 'hcyu' | 'cpv'
		politicalOrgOfficialDate: string
		cpvId: string | null
		educationLevel: string
		schoolName: string
		major: string
		isGraduated: boolean
		talent: string
		shortcoming: string
		policyBeneficiaryGroup: string
		fatherName: string
		fatherDob: string
		fatherPhoneNumber: string
		fatherJob: string
		/**
		 * fatherJobAddress: string;
		 */
		motherName: string

		motherDob: string
		motherPhoneNumber: string
		motherJob: string
		/**
		 * motherJobAddress: string;
		 */
		isMarried: boolean

		spouseName: string
		spouseDob: string
		spouseJob: string
		spousePhoneNumber: string
		familySize: number
		familyBackground: string
		familyBirthOrder: string
		achievement: string
		disciplinaryHistory: string
		childrenInfos: ChildrenInfo[]
		phone: string
		classId: number
	}

	export interface StudentDBResponse {
		id: number
		createdAt: string
		updatedAt: string
		fullName: string
		birthPlace: string
		address: string
		dob: string
		rank: string
		previousUnit: string
		previousPosition: string
		ethnic: string
		religion: string
		enlistmentPeriod: string
		politicalOrg: 'hcyu' | 'cpv'
		politicalOrgOfficialDate: string
		cpvId: string | null
		educationLevel: string
		schoolName: string
		major: string
		isGraduated: boolean
		talent: string
		shortcoming: string
		policyBeneficiaryGroup: string
		fatherName: string
		fatherDob: string
		fatherPhoneNumber: string
		fatherJob: string
		/**
		 * fatherJobAddress: string;
		 */
		motherName: string

		motherDob: string
		motherPhoneNumber: string
		motherJob: string
		/**
		 * motherJobAddress: string;
		 */
		isMarried: boolean

		spouseName: string
		spouseDob: string
		spouseJob: string
		spousePhoneNumber: string
		familySize: number
		familyBackground: string
		familyBirthOrder: string
		achievement: string
		disciplinaryHistory: string
		childrenInfos: ChildrenInfo[]
		phone: string
		classId: number
	}

	export type StudentParamsCronEvent =
		| 'birthdayThisWeek'
		| 'birthdayThisMonth'
		| 'birthdayThisQuarter'
		| 'cpvOfficialThisWeek'
		| 'cpvOfficialThisMonth'
		| 'cpvOfficialThisQuarter'

	export interface StudentResponse {
		class: {
			id: number
			description: string
			name: string
		}
		id: number
		createdAt: string
		updatedAt: string
		fullName: string
		birthPlace: string
		address: string
		dob: string
		rank: string
		previousUnit: string
		previousPosition: string
		ethnic: string
		religion: string
		enlistmentPeriod: string
		politicalOrg: 'hcyu' | 'cpv'
		politicalOrgOfficialDate: string
		cpvId: string | null
		educationLevel: string
		schoolName: string
		major: string
		isGraduated: boolean
		talent: string
		shortcoming: string
		policyBeneficiaryGroup: string
		fatherName: string
		fatherDob: string
		fatherPhoneNumber: string
		fatherJob: string
		/**
		 * fatherJobAddress: string;
		 */
		motherName: string

		motherDob: string
		motherPhoneNumber: string
		motherJob: string
		/**
		 * motherJobAddress: string;
		 */
		isMarried: boolean

		spouseName: string
		spouseDob: string
		spouseJob: string
		spousePhoneNumber: string
		familySize: number
		familyBackground: string
		familyBirthOrder: string
		achievement: string
		disciplinaryHistory: string
		childrenInfos: ChildrenInfo[]
		phone: string
		classId: number
	}

	export interface UpdatePayload {
		id: number
		fullName?: string
		birthPlace?: string
		address?: string
		dob?: string
		rank?: string
		previousUnit?: string
		previousPosition?: string
		ethnic?: string
		religion?: string
		enlistmentPeriod?: string
		politicalOrg?: 'hcyu' | 'cpv'
		politicalOrgOfficialDate?: string
		cpvId?: string | null
		educationLevel?: string
		schoolName?: string
		major?: string
		isGraduated?: boolean
		talent?: string
		shortcoming?: string
		policyBeneficiaryGroup?: string
		fatherName?: string
		fatherDob?: string
		fatherPhoneNumber?: string
		fatherJob?: string
		motherName?: string
		motherDob?: string
		motherPhoneNumber?: string
		motherJob?: string
		isMarried?: boolean
		spouseName?: string
		spouseDob?: string
		spouseJob?: string
		spousePhoneNumber?: string
		familySize?: number
		familyBackground?: string
		familyBirthOrder?: string
		achievement?: string
		disciplinaryHistory?: string
		childrenInfos?: ChildrenInfo[]
		phone?: string
		classId?: number
	}

	export interface UpdateStudentBody {
		data: UpdatePayload[]
	}

	export class ServiceClient {
		private baseClient: BaseClient

		constructor(baseClient: BaseClient) {
			this.baseClient = baseClient
			this.CreateStudent = this.CreateStudent.bind(this)
			this.DeleteStudents = this.DeleteStudents.bind(this)
			this.ExportPoliticsQualityReport =
				this.ExportPoliticsQualityReport.bind(this)
			this.ExportStudentData = this.ExportStudentData.bind(this)
			this.GetPoliticsQualityReport =
				this.GetPoliticsQualityReport.bind(this)
			this.GetStudents = this.GetStudents.bind(this)
			this.StudentCronjob = this.StudentCronjob.bind(this)
			this.UpdateStudents = this.UpdateStudents.bind(this)
		}

		public async CreateStudent(
			params: StudentBody
		): Promise<BulkStudentResponse> {
			// Now make the actual call to the API
			const resp = await this.baseClient.callTypedAPI(
				'POST',
				`/students`,
				JSON.stringify(params)
			)
			return (await resp.json()) as BulkStudentResponse
		}

		public async DeleteStudents(
			params: DeleteStudentRequest
		): Promise<DeleteStudentResponse> {
			// Convert our params into the objects we need for the request
			const query = makeRecord<string, string | string[]>({
				ids: params.ids.map((v) => String(v))
			})

			// Now make the actual call to the API
			const resp = await this.baseClient.callTypedAPI(
				'DELETE',
				`/students`,
				undefined,
				{ query }
			)
			return (await resp.json()) as DeleteStudentResponse
		}

		public async ExportPoliticsQualityReport(
			method: 'POST',
			body?: RequestInit['body'],
			options?: CallParameters
		): Promise<globalThis.Response> {
			return this.baseClient.callAPI(
				method,
				`/students/politics-quality-report/export`,
				body,
				options
			)
		}

		public async ExportStudentData(
			method: 'POST',
			body?: RequestInit['body'],
			options?: CallParameters
		): Promise<globalThis.Response> {
			return this.baseClient.callAPI(
				method,
				`/students/export`,
				body,
				options
			)
		}

		public async GetPoliticsQualityReport(
			params: GetPoliticsQualityReportRequest
		): Promise<GetPoliticsQualityReportResponse> {
			// Convert our params into the objects we need for the request
			const query = makeRecord<string, string | string[]>({
				unitIds: params.unitIds.map((v) => String(v))
			})

			// Now make the actual call to the API
			const resp = await this.baseClient.callTypedAPI(
				'GET',
				`/students/politics-quality-report`,
				undefined,
				{ query }
			)
			return (await resp.json()) as GetPoliticsQualityReportResponse
		}

		public async GetStudents(
			params: GetStudentsQuery
		): Promise<GetStudentsResponse> {
			// Convert our params into the objects we need for the request
			const query = makeRecord<string, string | string[]>({
				birthdayInMonth:
					params.birthdayInMonth === undefined
						? undefined
						: String(params.birthdayInMonth),
				birthdayInQuarter:
					params.birthdayInQuarter === undefined
						? undefined
						: String(params.birthdayInQuarter),
				birthdayInWeek:
					params.birthdayInWeek === undefined
						? undefined
						: String(params.birthdayInWeek),
				classId:
					params.classId === undefined
						? undefined
						: String(params.classId),
				classIds: params.classIds?.map((v) =>
					v === undefined ? undefined : String(v)
				),
				cpvOfficialInMonth:
					params.cpvOfficialInMonth === undefined
						? undefined
						: String(params.cpvOfficialInMonth),
				cpvOfficialInQuarter:
					params.cpvOfficialInQuarter === undefined
						? undefined
						: String(params.cpvOfficialInQuarter),
				hasReligion:
					params.hasReligion === undefined
						? undefined
						: String(params.hasReligion),
				ids: params.ids?.map((v) =>
					v === undefined ? undefined : String(v)
				),
				isCpvOfficialThisWeek:
					params.isCpvOfficialThisWeek === undefined
						? undefined
						: String(params.isCpvOfficialThisWeek),
				isEthnicMinority:
					params.isEthnicMinority === undefined
						? undefined
						: String(params.isEthnicMinority),
				isMarried:
					params.isMarried === undefined
						? undefined
						: String(params.isMarried),
				politicalOrg:
					params.politicalOrg === undefined
						? undefined
						: String(params.politicalOrg),
				unitAlias: params.unitAlias,
				unitLevel:
					params.unitLevel === undefined
						? undefined
						: String(params.unitLevel)
			})

			// Now make the actual call to the API
			const resp = await this.baseClient.callTypedAPI(
				'GET',
				`/students`,
				undefined,
				{ query }
			)
			return (await resp.json()) as GetStudentsResponse
		}

		public async StudentCronjob(params: {
			event: StudentParamsCronEvent
		}): Promise<void> {
			// Convert our params into the objects we need for the request
			const query = makeRecord<string, string | string[]>({
				event: String(params.event)
			})

			await this.baseClient.callTypedAPI(
				'GET',
				`/students/cron`,
				undefined,
				{ query }
			)
		}

		public async UpdateStudents(params: UpdateStudentBody): Promise<void> {
			await this.baseClient.callTypedAPI(
				'PATCH',
				`/students`,
				JSON.stringify(params)
			)
		}
	}
}

export namespace units {
	export interface GetUnitRequest {
		id?: number
		name?: string
		level?: 'battalion' | 'company'
		parentId?: number | null
	}

	export interface GetUnitResponse {
		data?: Unit
	}

	export interface GetUnitsQuery {
		level?: 'battalion' | 'company'
	}

	export interface GetUnitsResponse {
		data: Unit[]
	}

	export interface Unit {
		alias: string
		name: string
		level: 'battalion' | 'company'
		id: number
		createdAt: string
		updatedAt: string
		parent: unit | null
		children: Unit[]
		classes: classes.ClassResponse[]
	}

	export interface UnitDB {
		alias: string
		name: string
		level: 'battalion' | 'company'
		parentId?: number | null
		id: number
		createdAt: string
		updatedAt: string
	}

	export interface unit {
		alias: string
		name: string
		level: 'battalion' | 'company'
		id: number
		createdAt: string
		updatedAt: string
	}

	export class ServiceClient {
		private baseClient: BaseClient

		constructor(baseClient: BaseClient) {
			this.baseClient = baseClient
			this.GetUnit = this.GetUnit.bind(this)
			this.GetUnits = this.GetUnits.bind(this)
		}

		public async GetUnit(
			alias: string,
			params: GetUnitRequest
		): Promise<GetUnitResponse> {
			// Convert our params into the objects we need for the request
			const query = makeRecord<string, string | string[]>({
				id: params.id === undefined ? undefined : String(params.id),
				level:
					params.level === undefined
						? undefined
						: String(params.level),
				name: params.name,
				parentId:
					params.parentId === undefined
						? undefined
						: String(params.parentId)
			})

			// Now make the actual call to the API
			const resp = await this.baseClient.callTypedAPI(
				'GET',
				`/units/${encodeURIComponent(alias)}`,
				undefined,
				{ query }
			)
			return (await resp.json()) as GetUnitResponse
		}

		public async GetUnits(
			params: GetUnitsQuery
		): Promise<GetUnitsResponse> {
			// Convert our params into the objects we need for the request
			const query = makeRecord<string, string | string[]>({
				level:
					params.level === undefined
						? undefined
						: String(params.level)
			})

			// Now make the actual call to the API
			const resp = await this.baseClient.callTypedAPI(
				'GET',
				`/units`,
				undefined,
				{ query }
			)
			return (await resp.json()) as GetUnitsResponse
		}
	}
}

export namespace users {
	export interface CreateUserRequest {
		username: string
		password: string
		displayName: string
	}

	export interface CreateUserResponse {
		data: UserDB
	}

	export interface RoleDB {
		id: number
		createdAt: string
		updatedAt: string
		name: string
		description?: string
	}

	export interface User {
		roles: RoleDB[]
		id: number
		createdAt: string
		updatedAt: string
		username: string
		displayName: string
	}

	export interface UserDB {
		id: number
		createdAt: string
		updatedAt: string
		username: string
		displayName: string
	}

	export class ServiceClient {
		private baseClient: BaseClient

		constructor(baseClient: BaseClient) {
			this.baseClient = baseClient
			this.CreateUser = this.CreateUser.bind(this)
		}

		public async CreateUser(
			params: CreateUserRequest
		): Promise<CreateUserResponse> {
			// Now make the actual call to the API
			const resp = await this.baseClient.callTypedAPI(
				'POST',
				`/users`,
				JSON.stringify(params)
			)
			return (await resp.json()) as CreateUserResponse
		}
	}
}

function encodeQuery(parts: Record<string, string | string[]>): string {
	const pairs: string[] = []
	for (const key in parts) {
		const val = (
			Array.isArray(parts[key]) ? parts[key] : [parts[key]]
		) as string[]
		for (const v of val) {
			pairs.push(`${key}=${encodeURIComponent(v)}`)
		}
	}
	return pairs.join('&')
}

// makeRecord takes a record and strips any undefined values from it,
// and returns the same record with a narrower type.
// @ts-ignore - TS ignore because makeRecord is not always used
function makeRecord<K extends string | number | symbol, V>(
	record: Record<K, V | undefined>
): Record<K, V> {
	for (const key in record) {
		if (record[key] === undefined) {
			delete record[key]
		}
	}
	return record as Record<K, V>
}

function encodeWebSocketHeaders(headers: Record<string, string>) {
	// url safe, no pad
	const base64encoded = btoa(JSON.stringify(headers))
		.replaceAll('=', '')
		.replaceAll('+', '-')
		.replaceAll('/', '_')
	return 'encore.dev.headers.' + base64encoded
}

class WebSocketConnection {
	public ws: WebSocket

	private hasUpdateHandlers: (() => void)[] = []

	constructor(url: string, headers?: Record<string, string>) {
		let protocols = ['encore-ws']
		if (headers) {
			protocols.push(encodeWebSocketHeaders(headers))
		}

		this.ws = new WebSocket(url, protocols)

		this.on('error', () => {
			this.resolveHasUpdateHandlers()
		})

		this.on('close', () => {
			this.resolveHasUpdateHandlers()
		})
	}

	resolveHasUpdateHandlers() {
		const handlers = this.hasUpdateHandlers
		this.hasUpdateHandlers = []

		for (const handler of handlers) {
			handler()
		}
	}

	async hasUpdate() {
		// await until a new message have been received, or the socket is closed
		await new Promise((resolve) => {
			this.hasUpdateHandlers.push(() => resolve(null))
		})
	}

	on(
		type: 'error' | 'close' | 'message' | 'open',
		handler: (event: any) => void
	) {
		this.ws.addEventListener(type, handler)
	}

	off(
		type: 'error' | 'close' | 'message' | 'open',
		handler: (event: any) => void
	) {
		this.ws.removeEventListener(type, handler)
	}

	close() {
		this.ws.close()
	}
}

export class StreamInOut<Request, Response> {
	public socket: WebSocketConnection
	private buffer: Response[] = []

	constructor(url: string, headers?: Record<string, string>) {
		this.socket = new WebSocketConnection(url, headers)
		this.socket.on('message', (event: any) => {
			this.buffer.push(JSON.parse(event.data))
			this.socket.resolveHasUpdateHandlers()
		})
	}

	close() {
		this.socket.close()
	}

	async send(msg: Request) {
		if (this.socket.ws.readyState === WebSocket.CONNECTING) {
			// await that the socket is opened
			await new Promise((resolve) => {
				this.socket.ws.addEventListener('open', resolve, { once: true })
			})
		}

		return this.socket.ws.send(JSON.stringify(msg))
	}

	async next(): Promise<Response | undefined> {
		for await (const next of this) return next
		return undefined
	}

	async *[Symbol.asyncIterator](): AsyncGenerator<Response, undefined, void> {
		while (true) {
			if (this.buffer.length > 0) {
				yield this.buffer.shift() as Response
			} else {
				if (this.socket.ws.readyState === WebSocket.CLOSED) return
				await this.socket.hasUpdate()
			}
		}
	}
}

export class StreamIn<Response> {
	public socket: WebSocketConnection
	private buffer: Response[] = []

	constructor(url: string, headers?: Record<string, string>) {
		this.socket = new WebSocketConnection(url, headers)
		this.socket.on('message', (event: any) => {
			this.buffer.push(JSON.parse(event.data))
			this.socket.resolveHasUpdateHandlers()
		})
	}

	close() {
		this.socket.close()
	}

	async next(): Promise<Response | undefined> {
		for await (const next of this) return next
		return undefined
	}

	async *[Symbol.asyncIterator](): AsyncGenerator<Response, undefined, void> {
		while (true) {
			if (this.buffer.length > 0) {
				yield this.buffer.shift() as Response
			} else {
				if (this.socket.ws.readyState === WebSocket.CLOSED) return
				await this.socket.hasUpdate()
			}
		}
	}
}

export class StreamOut<Request, Response> {
	public socket: WebSocketConnection
	private responseValue: Promise<Response>

	constructor(url: string, headers?: Record<string, string>) {
		let responseResolver: (_: any) => void
		this.responseValue = new Promise(
			(resolve) => (responseResolver = resolve)
		)

		this.socket = new WebSocketConnection(url, headers)
		this.socket.on('message', (event: any) => {
			responseResolver(JSON.parse(event.data))
		})
	}

	async response(): Promise<Response> {
		return this.responseValue
	}

	close() {
		this.socket.close()
	}

	async send(msg: Request) {
		if (this.socket.ws.readyState === WebSocket.CONNECTING) {
			// await that the socket is opened
			await new Promise((resolve) => {
				this.socket.ws.addEventListener('open', resolve, { once: true })
			})
		}

		return this.socket.ws.send(JSON.stringify(msg))
	}
}
// CallParameters is the type of the parameters to a method call, but require headers to be a Record type
type CallParameters = Omit<RequestInit, 'method' | 'body' | 'headers'> & {
	/** Headers to be sent with the request */
	headers?: Record<string, string>

	/** Query parameters to be sent with the request */
	query?: Record<string, string | string[]>
}

// AuthDataGenerator is a function that returns a new instance of the authentication data required by this API
export type AuthDataGenerator = () =>
	| auth.AuthParams
	| Promise<auth.AuthParams | undefined>
	| undefined

// A fetcher is the prototype for the inbuilt Fetch function
export type Fetcher = typeof fetch

const boundFetch = fetch.bind(this)

class BaseClient {
	readonly baseURL: string
	readonly fetcher: Fetcher
	readonly headers: Record<string, string>
	readonly requestInit: Omit<RequestInit, 'headers'> & {
		headers?: Record<string, string>
	}
	readonly authGenerator?: AuthDataGenerator

	constructor(baseURL: string, options: ClientOptions) {
		this.baseURL = baseURL
		this.headers = {}

		// Add User-Agent header if the script is running in the server
		// because browsers do not allow setting User-Agent headers to requests
		if (!BROWSER) {
			this.headers['User-Agent'] =
				'ibibi-Generated-TS-Client (Encore/v1.49.1)'
		}

		this.requestInit = options.requestInit ?? {}

		// Setup what fetch function we'll be using in the base client
		if (options.fetcher !== undefined) {
			this.fetcher = options.fetcher
		} else {
			this.fetcher = boundFetch
		}

		// Setup an authentication data generator using the auth data token option
		if (options.auth !== undefined) {
			const auth = options.auth
			if (typeof auth === 'function') {
				this.authGenerator = auth
			} else {
				this.authGenerator = () => auth
			}
		}
	}

	async getAuthData(): Promise<CallParameters | undefined> {
		let authData: auth.AuthParams | undefined

		// If authorization data generator is present, call it and add the returned data to the request
		if (this.authGenerator) {
			const mayBePromise = this.authGenerator()
			if (mayBePromise instanceof Promise) {
				authData = await mayBePromise
			} else {
				authData = mayBePromise
			}
		}

		if (authData) {
			const data: CallParameters = {}

			data.headers = makeRecord<string, string>({
				authorization: authData.authorization
			})

			return data
		}

		return undefined
	}

	// createStreamInOut sets up a stream to a streaming API endpoint.
	async createStreamInOut<Request, Response>(
		path: string,
		params?: CallParameters
	): Promise<StreamInOut<Request, Response>> {
		let { query, headers } = params ?? {}

		// Fetch auth data if there is any
		const authData = await this.getAuthData()

		// If we now have authentication data, add it to the request
		if (authData) {
			if (authData.query) {
				query = { ...query, ...authData.query }
			}
			if (authData.headers) {
				headers = { ...headers, ...authData.headers }
			}
		}

		const queryString = query ? '?' + encodeQuery(query) : ''
		return new StreamInOut(this.baseURL + path + queryString, headers)
	}

	// createStreamIn sets up a stream to a streaming API endpoint.
	async createStreamIn<Response>(
		path: string,
		params?: CallParameters
	): Promise<StreamIn<Response>> {
		let { query, headers } = params ?? {}

		// Fetch auth data if there is any
		const authData = await this.getAuthData()

		// If we now have authentication data, add it to the request
		if (authData) {
			if (authData.query) {
				query = { ...query, ...authData.query }
			}
			if (authData.headers) {
				headers = { ...headers, ...authData.headers }
			}
		}

		const queryString = query ? '?' + encodeQuery(query) : ''
		return new StreamIn(this.baseURL + path + queryString, headers)
	}

	// createStreamOut sets up a stream to a streaming API endpoint.
	async createStreamOut<Request, Response>(
		path: string,
		params?: CallParameters
	): Promise<StreamOut<Request, Response>> {
		let { query, headers } = params ?? {}

		// Fetch auth data if there is any
		const authData = await this.getAuthData()

		// If we now have authentication data, add it to the request
		if (authData) {
			if (authData.query) {
				query = { ...query, ...authData.query }
			}
			if (authData.headers) {
				headers = { ...headers, ...authData.headers }
			}
		}

		const queryString = query ? '?' + encodeQuery(query) : ''
		return new StreamOut(this.baseURL + path + queryString, headers)
	}

	// callTypedAPI makes an API call, defaulting content type to "application/json"
	public async callTypedAPI(
		method: string,
		path: string,
		body?: RequestInit['body'],
		params?: CallParameters
	): Promise<Response> {
		return this.callAPI(method, path, body, {
			...params,
			headers: { 'Content-Type': 'application/json', ...params?.headers }
		})
	}

	// callAPI is used by each generated API method to actually make the request
	public async callAPI(
		method: string,
		path: string,
		body?: RequestInit['body'],
		params?: CallParameters
	): Promise<Response> {
		let { query, headers, ...rest } = params ?? {}
		const init = {
			...this.requestInit,
			...rest,
			method,
			body: body ?? null
		}

		// Merge our headers with any predefined headers
		init.headers = { ...this.headers, ...init.headers, ...headers }

		// Fetch auth data if there is any
		const authData = await this.getAuthData()

		// If we now have authentication data, add it to the request
		if (authData) {
			if (authData.query) {
				query = { ...query, ...authData.query }
			}
			if (authData.headers) {
				init.headers = { ...init.headers, ...authData.headers }
			}
		}

		// Make the actual request
		const queryString = query ? '?' + encodeQuery(query) : ''
		const response = await this.fetcher(
			this.baseURL + path + queryString,
			init
		)

		// handle any error responses
		if (!response.ok) {
			// try and get the error message from the response body
			let body: APIErrorResponse = {
				code: ErrCode.Unknown,
				message: `request failed: status ${response.status}`
			}

			// if we can get the structured error we should, otherwise give a best effort
			try {
				const text = await response.text()

				try {
					const jsonBody = JSON.parse(text)
					if (isAPIErrorResponse(jsonBody)) {
						body = jsonBody
					} else {
						body.message += ': ' + JSON.stringify(jsonBody)
					}
				} catch {
					body.message += ': ' + text
				}
			} catch (e) {
				// otherwise we just append the text to the error message
				body.message += ': ' + String(e)
			}

			throw new APIError(response.status, body)
		}

		return response
	}
}

/**
 * APIErrorDetails represents the response from an Encore API in the case of an error
 */
interface APIErrorResponse {
	code: ErrCode
	message: string
	details?: any
}

function isAPIErrorResponse(err: any): err is APIErrorResponse {
	return (
		err !== undefined &&
		err !== null &&
		isErrCode(err.code) &&
		typeof err.message === 'string' &&
		(err.details === undefined ||
			err.details === null ||
			typeof err.details === 'object')
	)
}

function isErrCode(code: any): code is ErrCode {
	return code !== undefined && Object.values(ErrCode).includes(code)
}

/**
 * APIError represents a structured error as returned from an Encore application.
 */
export class APIError extends Error {
	/**
	 * The HTTP status code associated with the error.
	 */
	public readonly status: number

	/**
	 * The Encore error code
	 */
	public readonly code: ErrCode

	/**
	 * The error details
	 */
	public readonly details?: any

	constructor(status: number, response: APIErrorResponse) {
		// extending errors causes issues after you construct them, unless you apply the following fixes
		super(response.message)

		// set error name as constructor name, make it not enumerable to keep native Error behavior
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target#new.target_in_constructors
		Object.defineProperty(this, 'name', {
			value: 'APIError',
			enumerable: false,
			configurable: true
		})

		// fix the prototype chain
		if ((Object as any).setPrototypeOf == undefined) {
			;(this as any).__proto__ = APIError.prototype
		} else {
			Object.setPrototypeOf(this, APIError.prototype)
		}

		// capture a stack trace
		if ((Error as any).captureStackTrace !== undefined) {
			;(Error as any).captureStackTrace(this, this.constructor)
		}

		this.status = status
		this.code = response.code
		this.details = response.details
	}
}

/**
 * Typeguard allowing use of an APIError's fields'
 */
export function isAPIError(err: any): err is APIError {
	return err instanceof APIError
}

export enum ErrCode {
	/**
	 * OK indicates the operation was successful.
	 */
	OK = 'ok',

	/**
	 * Canceled indicates the operation was canceled (typically by the caller).
	 *
	 * Encore will generate this error code when cancellation is requested.
	 */
	Canceled = 'canceled',

	/**
	 * Unknown error. An example of where this error may be returned is
	 * if a Status value received from another address space belongs to
	 * an error-space that is not known in this address space. Also
	 * errors raised by APIs that do not return enough error information
	 * may be converted to this error.
	 *
	 * Encore will generate this error code in the above two mentioned cases.
	 */
	Unknown = 'unknown',

	/**
	 * InvalidArgument indicates client specified an invalid argument.
	 * Note that this differs from FailedPrecondition. It indicates arguments
	 * that are problematic regardless of the state of the system
	 * (e.g., a malformed file name).
	 *
	 * This error code will not be generated by the gRPC framework.
	 */
	InvalidArgument = 'invalid_argument',

	/**
	 * DeadlineExceeded means operation expired before completion.
	 * For operations that change the state of the system, this error may be
	 * returned even if the operation has completed successfully. For
	 * example, a successful response from a server could have been delayed
	 * long enough for the deadline to expire.
	 *
	 * The gRPC framework will generate this error code when the deadline is
	 * exceeded.
	 */
	DeadlineExceeded = 'deadline_exceeded',

	/**
	 * NotFound means some requested entity (e.g., file or directory) was
	 * not found.
	 *
	 * This error code will not be generated by the gRPC framework.
	 */
	NotFound = 'not_found',

	/**
	 * AlreadyExists means an attempt to create an entity failed because one
	 * already exists.
	 *
	 * This error code will not be generated by the gRPC framework.
	 */
	AlreadyExists = 'already_exists',

	/**
	 * PermissionDenied indicates the caller does not have permission to
	 * execute the specified operation. It must not be used for rejections
	 * caused by exhausting some resource (use ResourceExhausted
	 * instead for those errors). It must not be
	 * used if the caller cannot be identified (use Unauthenticated
	 * instead for those errors).
	 *
	 * This error code will not be generated by the gRPC core framework,
	 * but expect authentication middleware to use it.
	 */
	PermissionDenied = 'permission_denied',

	/**
	 * ResourceExhausted indicates some resource has been exhausted, perhaps
	 * a per-user quota, or perhaps the entire file system is out of space.
	 *
	 * This error code will be generated by the gRPC framework in
	 * out-of-memory and server overload situations, or when a message is
	 * larger than the configured maximum size.
	 */
	ResourceExhausted = 'resource_exhausted',

	/**
	 * FailedPrecondition indicates operation was rejected because the
	 * system is not in a state required for the operation's execution.
	 * For example, directory to be deleted may be non-empty, an rmdir
	 * operation is applied to a non-directory, etc.
	 *
	 * A litmus test that may help a service implementor in deciding
	 * between FailedPrecondition, Aborted, and Unavailable:
	 *  (a) Use Unavailable if the client can retry just the failing call.
	 *  (b) Use Aborted if the client should retry at a higher-level
	 *      (e.g., restarting a read-modify-write sequence).
	 *  (c) Use FailedPrecondition if the client should not retry until
	 *      the system state has been explicitly fixed. E.g., if an "rmdir"
	 *      fails because the directory is non-empty, FailedPrecondition
	 *      should be returned since the client should not retry unless
	 *      they have first fixed up the directory by deleting files from it.
	 *  (d) Use FailedPrecondition if the client performs conditional
	 *      REST Get/Update/Delete on a resource and the resource on the
	 *      server does not match the condition. E.g., conflicting
	 *      read-modify-write on the same resource.
	 *
	 * This error code will not be generated by the gRPC framework.
	 */
	FailedPrecondition = 'failed_precondition',

	/**
	 * Aborted indicates the operation was aborted, typically due to a
	 * concurrency issue like sequencer check failures, transaction aborts,
	 * etc.
	 *
	 * See litmus test above for deciding between FailedPrecondition,
	 * Aborted, and Unavailable.
	 */
	Aborted = 'aborted',

	/**
	 * OutOfRange means operation was attempted past the valid range.
	 * E.g., seeking or reading past end of file.
	 *
	 * Unlike InvalidArgument, this error indicates a problem that may
	 * be fixed if the system state changes. For example, a 32-bit file
	 * system will generate InvalidArgument if asked to read at an
	 * offset that is not in the range [0,2^32-1], but it will generate
	 * OutOfRange if asked to read from an offset past the current
	 * file size.
	 *
	 * There is a fair bit of overlap between FailedPrecondition and
	 * OutOfRange. We recommend using OutOfRange (the more specific
	 * error) when it applies so that callers who are iterating through
	 * a space can easily look for an OutOfRange error to detect when
	 * they are done.
	 *
	 * This error code will not be generated by the gRPC framework.
	 */
	OutOfRange = 'out_of_range',

	/**
	 * Unimplemented indicates operation is not implemented or not
	 * supported/enabled in this service.
	 *
	 * This error code will be generated by the gRPC framework. Most
	 * commonly, you will see this error code when a method implementation
	 * is missing on the server. It can also be generated for unknown
	 * compression algorithms or a disagreement as to whether an RPC should
	 * be streaming.
	 */
	Unimplemented = 'unimplemented',

	/**
	 * Internal errors. Means some invariants expected by underlying
	 * system has been broken. If you see one of these errors,
	 * something is very broken.
	 *
	 * This error code will be generated by the gRPC framework in several
	 * internal error conditions.
	 */
	Internal = 'internal',

	/**
	 * Unavailable indicates the service is currently unavailable.
	 * This is a most likely a transient condition and may be corrected
	 * by retrying with a backoff. Note that it is not always safe to retry
	 * non-idempotent operations.
	 *
	 * See litmus test above for deciding between FailedPrecondition,
	 * Aborted, and Unavailable.
	 *
	 * This error code will be generated by the gRPC framework during
	 * abrupt shutdown of a server process or network connection.
	 */
	Unavailable = 'unavailable',

	/**
	 * DataLoss indicates unrecoverable data loss or corruption.
	 *
	 * This error code will not be generated by the gRPC framework.
	 */
	DataLoss = 'data_loss',

	/**
	 * Unauthenticated indicates the request does not have valid
	 * authentication credentials for the operation.
	 *
	 * The gRPC framework will generate this error code when the
	 * authentication metadata is invalid or a Credentials callback fails,
	 * but also expect authentication middleware to generate it.
	 */
	Unauthenticated = 'unauthenticated'
}
